 # 第七周 数组运算

 ## 学习目标
 1. 数组运算
 -数组运算
 -数组运算的例子

 2. 搜索
 -线性搜索
 -搜索的例子
 -二分搜索

 3. 排序初步
 -选择排序

## 1.1数组运算

①数组的集成初始化
-int a[] = {2，3，4}；
-int a[7]；
② 集成初始化时的定位
int a[10] = {[0]=2,[2]=3,6,}；→在C99中可以给具体位置赋值([1]= 0,[4]= 0,[3]= 6)
•用［n］在初始化数据中给出定位，没定位的数据接在前面的位置后面.
•其他位置的值补零.
•也可以不给出数组大小，让编译器算.
•特别适合初始数据稀疏的数组.
③数组的大小.
•sizeof 给出整个数组所占据的内容大小，单位是字节.
       -sizeof(a)/sizeof(a[0])这个代码永运对.
•sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数。
这样的代码，一旦修改数组中初始的数据，不需要修改遍历的代码.
④遍历数组.
•通常都是用for循环，让循环变量i从0到<数组的长度，这样循环体内最大的i正好是数组最大的有效下标
• 常见的错误：
   •循环结束的条件是<=数组长度，或；
   •离开循环后，继续用i的值来做数组元素的下标！

eg:
/**
找出key在数组a中的位置.
@param key是要寻找的数字.
@param a要寻找的数组.
@param length 数组a的长度.
@return 如果找到，返回其在a中的位置；
若找不到则返回-1.
*/
int search(int key,int a[],int length);
int main(void)
{
    int a[]={2,4,6,7,13,5};
    int x;
    int ioc;
    printf("请输入一个数字：");
    scanf("%d",&x);
    loc=search(x,a,sizeof(a)/sizeof(a[0]));
if(loc!=-1){
        printf("%d在第%d个位上\n",x,loc);
}else{
        printf("%d不存在\n",x);
}
        return 0;
}
int search(int key,int a[],int length)
 {
    int ret=-1;
    int i;
    for(i=0;i<length;i++){
        if( a[i] ==key ){
            ret=i;
            break;
        }
      }
        return ret;
}
 
 ## 1.2数组的例子：素数（大于1且只能被1和自身整除）
 -在之前，判断素数用了isPrime来判断
 -现在有另一个，算法原理：若一个数不能被任何小于它的已知素数整除，那么它就是素数。
 eg:
  int main(void)
  {
        const int number=100;
        int prime[number]={2};
        int count=1;
        int i=3;
        while(count<number){
                if(isPrime(i,prime,count)){
                        prime[count++]=i;
                }
        }
        i++;
  }
  for(i=0;i<number;i++){
        printf("%d",prime[i]);
        if((i+1)%5){
           printf("\t");
        }else{
            printf("\n");
       }
       return 0;
  }
  int isPrime(int x,int knownPrimes[],int numberofknownPrimes)
  {
        int ret=1;
        int i;
        for(i=0;i<numberofknownprime;i++){
                if(x%knownprimes[i]==0){
                 ret=0;
                 break;
                }
        }
        return ret;
  }
  函数isPrime其实是一个判断函数：
  -若返回1，则i为素数
  -若返回0，则i不为素数

  -还有一个构造素数表(预构造一个n以内的素数表)：
   -另x为2
   -将2x，3x，4x，直至ax<n的数标记为非素数
   -令x为下一个没有标记为非素数的的数，重复2；直到所有数都已经尝试完毕
   eg：
   #include<stdio.h>
   int main(void)
{
    const int maxnumber = 25;
    int isPrime[25];
    int i;
    int x;
    
    // 1. 初始化数组
    for(i = 0; i < maxnumber; i++) {
        isPrime[i] = 1;
    }
    
    // 2. 0和1不是素数
    isPrime[0] = 0;
    isPrime[1] = 0;
    
    // 3. 埃拉托斯特尼筛法
    for(x = 2; x < maxnumber; x++) {
        if(isPrime[x]) {
            for(i = 2; i * x < maxnumber; i++) {
                isPrime[i * x] = 0;
            }
        }
    }
    
    // 4. 输出素数（在筛选完成后）
    for(i = 2; i < maxnumber; i++) {
        if(isPrime[i]) {
            printf("%d\t", i);
        }
    }
    printf("\n");
    
    return 0;
}


## 2.1线性搜索

-搜索：
  -在一个数组中找到某个数的位置（或确认是否存在）
  -基本方法：遍历
  eg:#include <stdio.h>
     int search(int key,int a[],int len)
     {
        int ret=-1;
        for(int i=0;i<len i++)
        {
            if(key==a[i])
            {
                ret=i;
                break;
            }
        }
        return 0;
     }
     int main()
     {
        int a[]={1,3,2,17,12,5,6,}
        int r=search(12,a,sizeof(a)/sizeof(a[0]));
        printf("%d\n",r);
        return 0;
     }

## 2.2搜索的例子
eg：搜索一种面额，如{1，5，10，25，50，}的英文表达
#include <stdio.h>
int amount[]={1,5,10,25,50,};
char*name[]={"penny","nickel","dime","quarter","half-doallar"};
int search(int key,int a[],int len)
{
    int ret=-1;
    for(int i=0;i<len;i++)
    {
        if(key==a[i])
        {
            ret=i;
            break;
        
        }
    }
    return ret;
}
int main()
    {
        int k=10;
        int r=search(k,amount,sizeof(amount)/sizeof(amount[0]));
        if(r>-1)
        {
            printf("%s\n",name[r];)
        }
        return 0;
    }

## 2.3二分搜索
线性搜索太慢，而二分的效率更高
-经典寻找数字，可用“二分法”，即与中间数字对比大小（大于，则向右找；小于则向左找）
那么100个数，只需7次，1000个10次，可见代码跑得更快了
eg：搜索数字的函数（二分法）
int ret=-1;
int left=0;
int right=len-1;
while(right>left){
    int mid=(left+right)/2
    if(a[mid]==k)
    {
        ret=mid;
        break;
    }else if(a[mid]>k)
    {
        right=mid-1;
    }else{
        left=mid+1;
    }
}
return 0;

## 3.1排序初步
二分法的前提是数据已从小到大排好，那么现在来学习如何排序吧！
-先找最大
-再将其放置最后（即和最后一位换位）
-剩下的重复

#include <stdio.h>
int max(int a[],int len)
{
    int maxid=0;
    for(int i=1;i<len;i++)
    {
        if(a[i]>a[maxid])
        {
            maxid=1;
        }
    }
    return maxid;
}
int main()
{
    int a[]={2,45,6,12,87,34,90,24,23,11,65,};
    int len=sizeof(a)/sizeof(a[0]);
    for(int i=len-1;i>0;i--)
    {
        int maxid=max(a,i+1);
        int t=a[maxid];
        a[maxid]=a[i];
        a[i]=t;
    }
    for(int i=0;i<len;i++)
    {
        printf("%d",a[i]);
    }
    return 0;
}

## 作业

**学习日期**（2025.11.25-11.30）